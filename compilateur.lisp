(defun compilation-op (exp &optional env)
  (let ((op (car exp)) (arg1 (cadr exp)) (arg2 (caddr exp)) (reste (cdddr exp)))
    (if (null reste)
        (append (compilation arg1 env)
                '((PUSH :R0))
                (compilation arg2 env)
                '((MOVE :R0 :R1) (POP :R0))
                (case op
                  (+ '((ADD :R1 :R0)))
                  (- '((SUB :R1 :R0)))
                  (* '((MUL :R1 :R0)))
                  (/ '((DIV :R1 :R0)))))
        (compilation (cons op (cons (list op arg1 arg2) reste)) env))))

(defun compilation-fun (exp &optional env)
  (let ((nom (car exp)) (args (cdr exp)))
    (append (loop for arg in args
                  append (append (compilation arg env) '((PUSH :R0))))
            (if (symbolp nom)
                (list (list 'JSR nom))
                (append (compilation nom env) '((JSR :R0))))
            (when args (list (list 'SUB (list :CONST (length args)) :SP))))))

(defun compilation-defun (exp)
  (let ((nom (second exp)) (args (third exp)) (corps (cdddr exp)))
    (append (list (list 'LABEL nom))
            (loop with env = (list (cons nil args))
                  for e in corps
                  append (compilation e env))
            '((RTN)))))

(defun compilation-comp (exp &optional env)
  (let ((op (car exp)) (args (cdr exp))
        (l-false (gensym "FALSE")) (l-end (gensym "END")))
    (append (compilation (car args) env)
            (loop for next in (cdr args)
                  append (append '((PUSH :R0))
                                 (compilation next env)
                                 '((POP :R1) (CMP :R1 :R0))
                                 (case op
                                   (<  (list (list 'JGE l-false)))
                                   (>  (list (list 'JLE l-false)))
                                   (=  (list (list 'JNE l-false)))
                                   (<= (list (list 'JGT l-false)))
                                   (>= (list (list 'JLT l-false))))))
            (list (list 'MOVE '(:CONST 1) :R0)
                  (list 'JMP l-end)
                  (list 'LABEL l-false)
                  (list 'MOVE '(:CONST 0) :R0)
                  (list 'LABEL l-end)))))

(defun compilation-if (exp env)
  (let ((condi (second exp)) (alors (third exp)) (sinon (fourth exp))
        (l-else (gensym "ELSE")) (l-end (gensym "ENDIF")))
    (append (compilation condi env)
            (list (list 'TEST :R0) (list 'JEQ l-else))
            (compilation alors env)
            (list (list 'JMP l-end) (list 'LABEL l-else))
            (if sinon (compilation sinon env) '((MOVE (:CONST NIL) :R0)))
            (list (list 'LABEL l-end)))))

(defun compilation-let (exp env)
  (let* ((bindings (second exp)) (corps (cddr exp))
         (frame (or (car env) '(nil)))
         (new-locals (car frame)))
    (loop for b in bindings do (push (first b) new-locals))
    (let ((new-env (cons (cons new-locals (cdr frame)) (cdr env))))
      (append (loop for b in bindings
                    append (append (compilation (second b) env) '((PUSH :R0))))
              (loop for e in corps append (compilation e new-env))
              (when bindings (list (list 'SUB (list :CONST (length bindings)) :SP)))))))

(defun compilation-progn (exp env)
  (if (cdr exp)
      (loop for e in (cdr exp) append (compilation e env))
      '((MOVE (:CONST NIL) :R0))))

(defun compilation-while (exp env)
  (let ((condi (second exp)) (corps (cddr exp))
        (l-test (gensym "WTEST")) (l-end (gensym "WEND")))
    (append (list (list 'LABEL l-test))
            (compilation condi env)
            (list (list 'TEST :R0) (list 'JNIL l-end))
            (loop for e in corps append (compilation e env))
            (list (list 'JMP l-test) (list 'LABEL l-end) '(MOVE (:CONST NIL) :R0)))))

(defun compilation-setq (exp env)
  (let ((var (second exp)) (val (third exp)))
    (append (compilation val env)
            (let ((res (trouver-variable var env 0)))
              (if res
                  (list (list 'STORE :R0 (list :VAR (car res) (cdr res))))
                  (error "Variable inconnue pour SETQ : ~S" var))))))

(defun compilation-cons (exp env)
  (append (compilation (caddr exp) env)
          '((PUSH :R0))
          (compilation (cadr exp) env)
          '((POP :R1) (CONS :R0 :R1))))

(defun compilation-car (exp env)
  (append (compilation (cadr exp) env) '((CAR :R0))))

(defun compilation-cdr (exp env)
  (append (compilation (cadr exp) env) '((CDR :R0))))

(defun compilation-quote (exp env)
  (list (list 'MOVE (list :CONST (cadr exp)) :R0)))

(defvar *macros-table* (make-hash-table))
(defun get-defmacro (nom) (gethash nom *macros-table*))
(defun set-defmacro (nom fonction) (setf (gethash nom *macros-table*) fonction))

(defun compilation-defmacro (exp)
  (set-defmacro (second exp) (eval (list 'lambda (third exp) (cons 'progn (cdddr exp)))))
  nil)

(defun expansion-macro (exp)
  (let ((f (get-defmacro (car exp))))
    (if f (apply f (cdr exp)) exp)))

(defun transformer-backquote (exp)
  (cond ((atom exp) (list 'quote exp))
        ((eq (car exp) 'system::unquote) (second exp))
        ((and (consp (car exp)) (eq (caar exp) 'system::splice))
         (list 'append (second (car exp)) (transformer-backquote (cdr exp))))
        (t (list 'cons (transformer-backquote (car exp)) (transformer-backquote (cdr exp))))))

(defun compilation-lambda (exp env)
  (let ((args (second exp)) (corps (cddr exp))
        (l-fun (gensym "LAMBDA")) (l-skip (gensym "SKIP")))
    (append (list (list 'JMP l-skip) (list 'LABEL l-fun))
            (loop for e in corps append (compilation e (cons (cons nil args) env)))
            (list '(RTN) (list 'LABEL l-skip) (list 'MOVE (list :CONST l-fun) :R0)))))

(defun trouver-variable (var env depth)
  (if env
      (let* ((frame (car env))
             (p-loc (position var (car frame)))
             (p-arg (position var (cdr frame))))
        (cond (p-loc (cons depth (- (length (car frame)) p-loc)))
              (p-arg (cons depth (- 0 (+ 3 (- (length (cdr frame)) 1 p-arg)))))
              (t (trouver-variable var (cdr env) (1+ depth)))))
      nil))

(defun compilation (exp &optional env)
  (cond ((null exp)   '((MOVE (:CONST NIL) :R0)))
        ((eq exp t)   '((MOVE (:CONST 1) :R0)))
        ((numberp exp)(list (list 'MOVE (list :CONST exp) :R0)))
        ((symbolp exp)
         (let ((res (trouver-variable exp env 0)))
           (if res (list (list 'MOVE (list :VAR (car res) (cdr res)) :R0))
               (error "Variable inconnue : ~S" exp))))
        ((atom exp)   (list (list 'MOVE (list :CONST exp) :R0)))
        ((eq (car exp) 'defun)    (compilation-defun exp))
        ((eq (car exp) 'lambda)   (compilation-lambda exp env))
        ((eq (car exp) 'if)       (compilation-if exp env))
        ((eq (car exp) 'let)      (compilation-let exp env))
        ((eq (car exp) 'progn)    (compilation-progn exp env))
        ((eq (car exp) 'while)    (compilation-while exp env))
        ((eq (car exp) 'setq)     (compilation-setq exp env))
        ((eq (car exp) 'defmacro) (compilation-defmacro exp))
        ((and (symbolp (car exp)) (get-defmacro (car exp)))
         (compilation (expansion-macro exp) env))
        ((and (consp exp) (eq (car exp) 'system::backquote))
         (compilation (transformer-backquote (second exp)) env))
        ((eq (car exp) 'cons)  (compilation-cons exp env))
        ((eq (car exp) 'car)   (compilation-car exp env))
        ((eq (car exp) 'cdr)   (compilation-cdr exp env))
        ((eq (car exp) 'quote) (compilation-quote exp env))
        ((eq (car exp) 'print) (append (compilation (second exp) env) '((PRIN :R0))))
        ((member (car exp) '(+ - * /)) (compilation-op exp env))
        ((member (car exp) '(< > = <= >=)) (compilation-comp exp env))
        (t (compilation-fun exp env))))

(defun compiler-fichier ()
  (let (funcs main)
    (with-open-file (s "code.lisp")
      (do ((e (read s nil 'eof) (read s nil 'eof))) ((eq e 'eof))
        (if (and (listp e) (eq (car e) 'defun))
            (setf funcs (append funcs (compilation-defun e)))
            (setf main (append main (compilation e))))))
    (let ((code (append '((JMP :START)) funcs '((LABEL :START)) main '((HALT)))))
      (with-open-file (out "cible.asm" :direction :output :if-exists :supersede)
        (let ((*print-gensym* nil))
          (dolist (c code) (print c out))))
      code)))