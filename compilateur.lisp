(defun compilation-op (exp &optional env)
  (let ((op (car exp)) (arg1 (cadr exp)) (arg2 (caddr exp)) (reste (cdddr exp)))
    (if (null reste)
        (append (compilation arg1 env)
                '((PUSH :R0))
                (compilation arg2 env)
                '((MOVE :R0 :R1) (POP :R0))
                (case op
                  (+ '((ADD :R1 :R0)))
                  (- '((SUB :R1 :R0)))
                  (* '((MUL :R1 :R0)))
                  (/ '((DIV :R1 :R0)))))
        (compilation (cons op (cons (list op arg1 arg2) reste)) env))))

(defun compilation-fun (exp &optional env)
  (let ((nom (car exp)) (args (cdr exp)))
    (append (loop for arg in args
                  append (append (compilation arg env) '((PUSH :R0))))
            ;; Empile le nombre d'arguments pour que la VM puisse les récupérer
            (list (list 'PUSH (list :CONST (length args))))
            (if (symbolp nom)
                (list (list 'JSR nom))
                (append (compilation nom env) '((JSR :R0))))
            ;; Nettoie la pile: args + compteur
            (list (list 'SUB (list :CONST (1+ (length args))) :SP)))))

(defun compilation-defun (exp)
  (let ((nom (second exp)) (args (third exp)) (corps (cdddr exp)))
    (append (list (list 'LABEL nom))
            (loop with env = (list (cons nil args))
                  for e in corps
                  append (compilation e env))
            '((RTN)))))

(defun compilation-comp (exp &optional env)
  (let ((op (car exp)) (args (cdr exp))
        (l-false (gensym "FALSE")) (l-end (gensym "END")))
    (append (compilation (car args) env)
            (loop for next in (cdr args)
                  append (append '((PUSH :R0))
                                 (compilation next env)
                                 '((POP :R1) (CMP :R1 :R0))
                                 (case op
                                   (<  (list (list 'JGE l-false)))
                                   (>  (list (list 'JLE l-false)))
                                   (=  (list (list 'JNE l-false)))
                                   (<= (list (list 'JGT l-false)))
                                   (>= (list (list 'JLT l-false))))))
            (list (list 'MOVE '(:CONST 1) :R0)
                  (list 'JMP l-end)
                  (list 'LABEL l-false)
                  (list 'MOVE '(:CONST 0) :R0)
                  (list 'LABEL l-end)))))

(defun compilation-if (exp env)
  (let ((condi (second exp)) (alors (third exp)) (sinon (fourth exp))
        (l-else (gensym "ELSE")) (l-end (gensym "ENDIF")))
    (append (compilation condi env)
            (list (list 'TEST :R0) (list 'JEQ l-else))
            (compilation alors env)
            (list (list 'JMP l-end) (list 'LABEL l-else))
            (if sinon (compilation sinon env) '((MOVE (:CONST NIL) :R0)))
            (list (list 'LABEL l-end)))))

(defun compilation-let (exp env)
  (let* ((bindings (second exp)) (corps (cddr exp))
         (frame (or (car env) '(nil)))
         (new-locals (car frame)))
    (loop for b in bindings do (push (first b) new-locals))
    (let ((new-env (cons (cons new-locals (cdr frame)) (cdr env))))
      (append (loop for b in bindings
                    append (append (compilation (second b) env) '((PUSH :R0))))
              (loop for e in corps append (compilation e new-env))
              (when bindings (list (list 'SUB (list :CONST (length bindings)) :SP)))))))

(defun compilation-progn (exp env)
  (if (cdr exp)
      (loop for e in (cdr exp) append (compilation e env))
      '((MOVE (:CONST NIL) :R0))))

(defun compilation-while (exp env)
  (let ((condi (second exp)) (corps (cddr exp))
        (l-test (gensym "WTEST")) (l-end (gensym "WEND")))
    (append (list (list 'LABEL l-test))
            (compilation condi env)
            (list (list 'TEST :R0) (list 'JNIL l-end))
            (loop for e in corps append (compilation e env))
            (list (list 'JMP l-test) (list 'LABEL l-end) '(MOVE (:CONST NIL) :R0)))))

(defun compilation-loop (exp env)
  (let* ((c-var nil)
         (it-var nil) (it-type nil) (it-from nil) (it-to nil) (it-in nil)
         (collecting nil) (body nil) (finally nil))
    (labels ((parse (c)
               (cond ((null c) nil)
                     ((eq (car c) 'for)
                      (setf it-var (cadr c) it-type (caddr c))
                      (cond ((eq it-type 'from)
                             (setf it-from (cadddr c))
                             (when (eq (nth 4 c) 'to) (setf it-to (nth 5 c)))
                             (parse (nthcdr 6 c)))
                            ((eq it-type 'in)
                             (setf it-in (cadddr c))
                             (parse (nthcdr 4 c)))))
                     ((eq (car c) 'do) (push (cadr c) body) (parse (cddr c)))
                     ((eq (car c) 'collect)
                      (setf collecting t)
                      (when (eq (caddr c) 'into)
                        (setf c-var (cadddr c)))
                      (unless c-var (setf c-var (gensym "COL")))
                      (push `(setq ,c-var (cons ,(cadr c) ,c-var)) body)
                      (if (eq (caddr c) 'into) (parse (nthcdr 4 c)) (parse (cddr c))))
                     ((eq (car c) 'finally) (setf finally (cdr c)) nil)
                     (t (parse (cdr c))))))
      (parse (cdr exp))
      (let* ((body-code (nreverse body))
             (loop-it (cond
                        (it-from `(let ((,it-var ,it-from))
                                    (while (<= ,it-var ,it-to)
                                      ,@body-code
                                      (setq ,it-var (+ ,it-var 1)))))
                        (it-in (let ((tmp (gensym)))
                                 `(let ((,tmp ,it-in))
                                    (while ,tmp
                                      (let ((,it-var (car ,tmp)))
                                        ,@body-code
                                        (setq ,tmp (cdr ,tmp)))))))
                        (t `(while t ,@body-code)))))
        (if collecting
            (compilation `(let ((,c-var nil))
                            ,loop-it
                            ,@finally
                            (let ((_r nil))
                              (while ,c-var
                                (setq _r (cons (car ,c-var) _r))
                                (setq ,c-var (cdr ,c-var)))
                              _r))
                         env)
            (compilation `(progn ,loop-it ,@finally) env))))))

(defun compilation-setq (exp env)
  (let ((var (second exp)) (val (third exp)))
    (append (compilation val env)
            (let ((res (trouver-variable var env 0)))
              (if res
                  (list (list 'STORE :R0 (list :VAR (car res) (cdr res))))
                  (error "Variable inconnue pour SETQ : ~S" var))))))

(defun compilation-cons (exp env)
  (append (compilation (caddr exp) env)
          '((PUSH :R0))
          (compilation (cadr exp) env)
          '((POP :R1) (CONS :R0 :R1))))

(defun compilation-car (exp env)
  (append (compilation (cadr exp) env) '((CAR :R0))))

(defun compilation-cdr (exp env)
  (append (compilation (cadr exp) env) '((CDR :R0))))

(defun compilation-cond (exp env)
  (labels ((build (clauses)
             (if (null clauses)
                 nil
                 (let ((c (car clauses)))
                   (if (eq (car c) t)
                       `(progn ,@(cdr c))
                       `(if ,(car c) (progn ,@(cdr c)) ,(build (cdr clauses))))))))
    (compilation (build (cdr exp)) env)))

(defun compilation-case (exp env)
  (let ((key-var (gensym "KEY")))
    (labels ((build (clauses)
               (if (null clauses)
                   nil
                   (let ((c (car clauses)))
                     (if (member (car c) '(t otherwise))
                         `(progn ,@(cdr c))
                         `(if (= ,key-var ,(car c)) (progn ,@(cdr c)) ,(build (cdr clauses))))))))
      (compilation `(let ((,key-var ,(cadr exp))) ,(build (cddr exp))) env))))

(defun compilation-quote (exp env)
  (list (list 'MOVE (list :CONST (cadr exp)) :R0)))

(defvar *macros-table* (make-hash-table))
(defun get-defmacro (nom) (gethash nom *macros-table*))
(defun set-defmacro (nom fonction) (setf (gethash nom *macros-table*) fonction))

(defun compilation-defmacro (exp)
  (set-defmacro (second exp) (eval (list 'lambda (third exp) (cons 'progn (cdddr exp)))))
  nil)

(defun expansion-macro (exp)
  (let ((f (get-defmacro (car exp))))
    (if f (apply f (cdr exp)) exp)))

(defun transformer-backquote (exp)
  (cond ((atom exp) (list 'quote exp))
        ((eq (car exp) 'system::unquote) (second exp))
        ((and (consp (car exp)) (eq (caar exp) 'system::splice))
         (list 'append (second (car exp)) (transformer-backquote (cdr exp))))
        (t (list 'cons (transformer-backquote (car exp)) (transformer-backquote (cdr exp))))))

(defun compilation-lambda (exp env)
  (let ((args (second exp)) (corps (cddr exp))
        (l-fun (gensym "LAMBDA")) (l-skip (gensym "SKIP")))
    (append (list (list 'JMP l-skip) (list 'LABEL l-fun))
            (loop for e in corps append (compilation e (cons (cons nil args) env)))
            (list '(RTN) (list 'LABEL l-skip) (list 'MOVE (list :CONST l-fun) :R0)))))

(defun trouver-variable (var env depth)
  (if env
      (let* ((frame (car env))
             (p-loc (position var (car frame)))
             (p-arg (position var (cdr frame))))
        (cond (p-loc (cons depth (- (length (car frame)) p-loc)))
              (p-arg (cons depth (- 0 (+ 3 (- (length (cdr frame)) 1 p-arg)))))
              (t (trouver-variable var (cdr env) (1+ depth)))))
      nil))

(defun compilation (exp &optional env)
  (cond ((null exp)   '((MOVE (:CONST NIL) :R0)))
        ((eq exp t)   '((MOVE (:CONST 1) :R0)))
        ((numberp exp)(list (list 'MOVE (list :CONST exp) :R0)))
        ((keywordp exp) (list (list 'MOVE (list :CONST exp) :R0)))  ; Keywords comme constantes
        ((symbolp exp)
         (let ((res (trouver-variable exp env 0)))
           (if res (list (list 'MOVE (list :VAR (car res) (cdr res)) :R0))
               (error "Variable inconnue : ~S" exp))))
        ((atom exp)   (list (list 'MOVE (list :CONST exp) :R0)))
        ((eq (car exp) 'defun)    (compilation-defun exp))
        ((eq (car exp) 'lambda)   (compilation-lambda exp env))
        ((eq (car exp) 'if)       (compilation-if exp env))
        ((eq (car exp) 'let)      (compilation-let exp env))
        ((eq (car exp) 'progn)    (compilation-progn exp env))
        ((eq (car exp) 'while)    (compilation-while exp env))
        ((eq (car exp) 'loop)     (compilation-loop exp env))
        ((eq (car exp) 'cond)     (compilation-cond exp env))
        ((eq (car exp) 'case)     (compilation-case exp env))
        ((eq (car exp) 'setq)     (compilation-setq exp env))
        ((eq (car exp) 'defmacro) (compilation-defmacro exp))
        ((and (symbolp (car exp)) (get-defmacro (car exp)))
         (compilation (expansion-macro exp) env))
        ((and (consp exp) (eq (car exp) 'system::backquote))
         (compilation (transformer-backquote (second exp)) env))
        ((eq (car exp) 'cons)  (compilation-cons exp env))
        ((eq (car exp) 'car)   (compilation-car exp env))
        ((eq (car exp) 'cdr)   (compilation-cdr exp env))
        ((eq (car exp) 'quote) (compilation-quote exp env))
        ((eq (car exp) 'print) (append (compilation (second exp) env) '((PRIN :R0))))
        ((member (car exp) '(+ - * /)) (compilation-op exp env))
        ((member (car exp) '(< > = <= >=)) (compilation-comp exp env))
        (t (compilation-fun exp env))))

(defun compiler-fichier ()
  (let (funcs main)
    (with-open-file (s "code.lisp")
      (do ((e (read s nil 'eof) (read s nil 'eof))) ((eq e 'eof))
        (if (and (listp e) (eq (car e) 'defun))
            (setf funcs (append funcs (compilation-defun e)))
            (setf main (append main (compilation e))))))
    (let ((code (append '((JMP :START)) funcs '((LABEL :START) (MOVE :SP :FP)) main '((HALT)))))
      (with-open-file (out "cible.asm" :direction :output :if-exists :supersede)
        (let ((*print-gensym* nil))
          (dolist (c code) (print c out))))
      code)))