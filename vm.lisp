(require "utils/utils.lisp")

(defun vm_make (name size)
  (set-prop name :name name)
  (mapc (lambda (pair) (set-prop name (car pair) (cdr pair)))
        '((:R0 . 0) (:R1 . 0) (:R2 . 0) (:R3 . 0)
          (:BP . 500) (:SP . 500) (:FP . 0)
          (:FLT . 0) (:FEQ . 0) (:FGT . 0)
          (:PC . 0) (:LC . 0)))
  (set-prop name :labels (make-hash-table))
  (set-prop name :mem (make-array size :initial-element 0))
  'ok)

(defun vm_run (vm)
  (loop
    (let* ((pc (get-prop vm :PC))
           (inst (get-mem vm pc)))
      (cond
        ((not (listp inst))
         (format t "ERREUR FATALE : PC (~D) pointe sur une donn√©e brute : ~S~%" pc inst)
         (return 'CRASH))
        ((or (null inst) (eq (first inst) 'HALT))
         (return 'DONE)))
      
      (set-prop vm :PC (1+ pc))
      
      (let ((op (first inst))
            (args (rest inst)))
        (case op
          (LOAD   (vm_exec_inst_LOAD vm (first args) (second args)))
          (STORE  (vm_exec_inst_STORE vm (first args) (second args)))
          (MOVE   (vm_exec_inst_MOVE vm (first args) (second args)))
          (ADD    (vm_exec_inst_ADD vm (first args) (second args)))
          (SUB    (vm_exec_inst_SUB vm (first args) (second args)))
          (MUL    (vm_exec_inst_MUL vm (first args) (second args)))
          (DIV    (vm_exec_inst_DIV vm (first args) (second args)))
          (INCR   (vm_exec_inst_INCR vm (first args)))
          (DECR   (vm_exec_inst_DECR vm (first args)))
          (PUSH   (vm_exec_inst_PUSH vm (first args)))
          (POP    (vm_exec_inst_POP vm (first args)))
          (JMP    (vm_exec_inst_JMP vm (first args)))
          (JSR    (vm_exec_inst_JSR vm (first args)))
          (RTN    (vm_exec_inst_RTN vm))
          (CMP    (vm_exec_inst_CMP vm (first args) (second args)))
          (JGT    (vm_exec_inst_JGT vm (first args)))
          (JGE    (vm_exec_inst_JGE vm (first args)))
          (JLT    (vm_exec_inst_JLT vm (first args)))
          (JLE    (vm_exec_inst_JLE vm (first args)))
          (JEQ    (vm_exec_inst_JEQ vm (first args)))
          (JNE    (vm_exec_inst_JNE vm (first args)))
          (TEST   (vm_exec_inst_TEST vm (first args)))
          (JTRUE  (vm_exec_inst_JTRUE vm (first args)))
          (JNIL   (vm_exec_inst_JNIL vm (first args)))
          (CONS   (set-prop vm :R0 (cons (read_value vm (first args)) (read_value vm (second args)))))
          (CAR    (let ((l (read_value vm (first args)))) (set-prop vm :R0 (if (consp l) (car l) nil))))
          (CDR    (let ((l (read_value vm (first args)))) (set-prop vm :R0 (if (consp l) (cdr l) nil))))
          (PRIN   (vm_exec_inst_PRIN vm (first args))))))))

(defun resolve-argument (arg label-map)
  (cond
    ((and (symbolp arg) (gethash arg label-map))
     (gethash arg label-map))
    ((and (listp arg) (eq (first arg) :CONST)
          (symbolp (second arg)) (gethash (second arg) label-map))
     (list :CONST (gethash (second arg) label-map)))
    (t arg)))

(defun vm_load (code-list vm)
  (let ((addr 0)
        (label-map (make-hash-table))
        (resolved-code nil))
    (dolist (inst code-list)
      (if (eq (first inst) 'LABEL)
          (setf (gethash (second inst) label-map) addr)
          (incf addr)))
    (dolist (inst code-list)
      (unless (eq (first inst) 'LABEL)
        (push (cons (first inst) 
                    (mapcar (lambda (arg) (resolve-argument arg label-map)) (rest inst)))
              resolved-code)))
    (setf resolved-code (nreverse resolved-code))
    (setf addr 0)
    (dolist (inst resolved-code)
      (set-mem vm addr inst)
      (incf addr))
    (set-prop vm :labels label-map)))

(defun resolve_addr (vm src)
  (cond
    ((integerp src) src)
    ((listp src)
     (case (first src)
       (:REF   (read_value vm (second src)))
       (+      (+ (read_value vm (second src)) (third src)))
       (:CONST (second src))
       (:VAR   (let ((current-fp (get-prop vm :FP)))
                 (dotimes (i (second src))
                   (setf current-fp (get-mem vm (- current-fp 2))))
                 (+ current-fp (third src))))
       (t (error "Type inconnu : ~S" src))))
    (t (error "Arg invalide : ~S" src))))

(defun vm_exec_inst_LOAD (vm src dest)
  (let ((val (get-mem vm (resolve_addr vm src))))
    (if (symbolp dest)
        (set-prop vm dest val)
        (set-mem vm dest val))))

(defun vm_exec_inst_STORE (vm src dest)
  (set-mem vm (resolve_addr vm dest) (read_value vm src)))

(defun vm_exec_inst_MOVE (vm src dest)
  (let ((val (read_value vm src))
        (target (if (listp dest) (resolve_addr vm dest) dest)))
    (if (symbolp target)
        (set-prop vm target val)
        (set-mem vm target val))))

(defun vm_exec_inst_ADD (vm src dest)
  (write_value vm dest (+ (read_value vm src) (read_value vm dest))))

(defun vm_exec_inst_SUB (vm src dest)
  (write_value vm dest (- (read_value vm dest) (read_value vm src))))

(defun vm_exec_inst_MUL (vm src dest)
  (write_value vm dest (* (read_value vm src) (read_value vm dest))))

(defun vm_exec_inst_DIV (vm src dest)
  (write_value vm dest (truncate (/ (read_value vm dest) (read_value vm src)))))

(defun vm_exec_inst_INCR (vm dest)
  (let ((target (if (listp dest) (resolve_addr vm dest) dest)))
    (set-mem vm target (1+ (read_value vm dest)))))

(defun vm_exec_inst_DECR (vm dest)
  (let ((target (if (listp dest) (resolve_addr vm dest) dest)))
    (set-mem vm target (1- (read_value vm dest)))))

(defun vm_exec_inst_PUSH (vm src)
  (vm_exec_inst_INCR vm :SP)
  (vm_exec_inst_MOVE vm src '(:REF :SP)))

(defun vm_exec_inst_POP (vm dest)
  (vm_exec_inst_MOVE vm '(:REF :SP) dest)
  (vm_exec_inst_DECR vm :SP))

(defun vm_exec_inst_JMP (vm target)
  (if (integerp target)
      (set-prop vm :PC target)
      (error "Erreur JMP : Adresse ~S invalide" target)))

(defun vm_exec_inst_JSR (vm cible)
  (let ((adresse-saut (cond ((integerp cible) cible)
                            ((keywordp cible) (read_value vm cible))
                            (t (error "JSR : Cible invalide ~S" cible)))))
    (vm_exec_inst_PUSH vm (list :CONST (get-prop vm :FP)))
    (vm_exec_inst_PUSH vm (list :CONST (get-prop vm :PC)))
    (vm_exec_inst_PUSH vm (list :CONST (get-prop vm :FP)))
    (set-prop vm :FP (get-prop vm :SP))
    (set-prop vm :PC adresse-saut)))

(defun vm_exec_inst_RTN (vm)
  (set-prop vm :SP (get-prop vm :FP))
  (vm_exec_inst_POP vm :FP)
  (vm_exec_inst_POP vm :PC)
  (vm_exec_inst_POP vm :R2))

(defun vm_exec_inst_CMP (vm src1 src2)
  (let ((val1 (read_value vm src1))
        (val2 (read_value vm src2)))
    (set-mem vm :FLT 0)
    (set-mem vm :FEQ 0)
    (set-mem vm :FGT 0)
    (cond
      ((and (numberp val1) (numberp val2))
       (cond ((< val1 val2) (set-mem vm :FLT 1))
             ((= val1 val2) (set-mem vm :FEQ 1))
             ((> val1 val2) (set-mem vm :FGT 1))))
      (t (if (equal val1 val2) (set-mem vm :FEQ 1))))))

(defun vm_exec_inst_JGT (vm label) (vm_jmp_cond_helper vm 0 0 1 label))
(defun vm_exec_inst_JGE (vm label) (vm_jmp_cond_helper vm 0 1 1 label))
(defun vm_exec_inst_JLT (vm label) (vm_jmp_cond_helper vm 1 0 0 label))
(defun vm_exec_inst_JLE (vm label) (vm_jmp_cond_helper vm 1 1 0 label))
(defun vm_exec_inst_JEQ (vm label) (vm_jmp_cond_helper vm 0 1 0 label))
(defun vm_exec_inst_JNE (vm label) (vm_jmp_cond_helper vm 1 0 1 label))

(defun vm_exec_inst_TEST (vm src)
  (let ((val (read_value vm src)))
    (set-mem vm :FEQ 0)
    (set-mem vm :FGT 0)
    (if (or (null val) (and (numberp val) (= val 0)))
        (set-mem vm :FEQ 1)
        (set-mem vm :FGT 1))))

(defun vm_exec_inst_JTRUE (vm label) (vm_jmp_cond_helper vm 0 0 1 label))
(defun vm_exec_inst_JNIL (vm label) (vm_jmp_cond_helper vm 0 1 0 label))

(defun vm_exec_inst_PRIN (vm src)
  (let ((val (read_value vm src)))
    (format t "~S~%" val)
    (set-prop vm :R0 val)))

(defun executer-cible ()
  (vm_make 'vm 5000)
  (let ((code-charge nil))
    (with-open-file (stream "cible.asm" :direction :input)
      (do ((ins (read stream nil 'eof) (read stream nil 'eof)))
          ((eq ins 'eof))
        (push ins code-charge)))
    (vm_load (nreverse code-charge) 'vm)
    (vm_run 'vm)
    (print (get-prop 'vm :R0))))